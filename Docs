java.sql.SQLException: Can not issue data manipulation statements with executeQuery()

@Transactional
    @Modifying
    @Query("UPDATE YourEntity e SET e.column1 = :newColumn1, e.column2 = :newColumn2 WHERE e.id = :id")
    void updateColumns(@Param("id") Long id, @Param("newColumn1") String newColumn1, @Param("newColumn2") String newColumn2);

DELIMITER //

CREATE PROCEDURE YourInsertProcedure()
BEGIN
    -- Your Common Table Expressions (CTEs)
    WITH CTE1 AS (
        SELECT CHANNEL_NAME, appliance_REQUEST_URL, COUNT(appliance_INTERACTION_ID) AS TOTAL_CALL
        FROM CombinedData
        GROUP BY CHANNEL_NAME, appliance_REQUEST_URL
    ),
    CTE2 AS (
        -- Another CTE if needed
        -- ...
    )

    -- Insert data into the destination table from the CTEs
    INSERT INTO EFR_STATS (CHANNEL, REQUEST_URL, TOTAL_API_CALL)
    SELECT CHANNEL_NAME, appliance_REQUEST_URL, TOTAL_CALL
    FROM CTE1;

    -- Your logic after the insert statement if needed
END //

DELIMITER ;


INSERT INTO EFR_STATS(CHANNEL,REQUEST_URL,TOTAL_API_CALL) SELECT CHANNEL_NAME,appliance_REQUEST_URL,count(appliance_INTERACTION_ID) AS TOTAL_CALL FROM CombinedData group by CHANNEL_NAME,appliance_REQUEST_URL;

DELIMITER //

CREATE PROCEDURE CheckItemsExistence(
    IN p_item_list TEXT
)
BEGIN
    -- Declare a variable to store the result
    DECLARE result VARCHAR(255);

    -- Your logic to check if any item in the list exists in the table column
    SELECT CASE
        WHEN EXISTS (
            SELECT 1
            FROM your_table
            WHERE FIND_IN_SET(your_column, p_item_list)
        ) THEN 'Some items exist in the column'
        ELSE 'No items found'
    END INTO result;

    -- You can now use or return the result as needed
    SELECT result AS Result;
END //

DELIMITER ;
CALL CheckItemsExistence('item1,item2,item3');


DELIMITER //

CREATE PROCEDURE OuterProcedure()
BEGIN
    DECLARE exit_handler BOOLEAN DEFAULT FALSE;

    -- Declare a continue handler to catch any SQL exceptions
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        -- Set the exit_handler to TRUE to indicate an exception
        SET exit_handler = TRUE;
    END;

    -- Your logic for the outer procedure
    -- ...

    -- Call the inner procedure, and if it fails, the handler will be triggered,
    -- but the outer procedure will continue executing
    CALL InnerProcedure();

    -- Check if an exception occurred in the inner procedure
    IF exit_handler THEN
        -- Handle the exception if needed
        -- You can log the error, set a status variable, etc.
        -- For example:
        -- SET status_variable = 'Failure';
    END IF;

    -- Continue with the rest of the outer procedure logic
    -- ...

END //

DELIMITER ;



DELIMITER //

CREATE PROCEDURE YourProcedure()
BEGIN
    -- Declare variables for job details
    DECLARE job_name VARCHAR(255);
    DECLARE start_time DATETIME;
    DECLARE end_time DATETIME;
    DECLARE job_status ENUM('RUNNING', 'SUCCESS', 'FAILURE');
    DECLARE job_details TEXT;

    -- Set job details
    SET job_name = 'YourJobName'; -- Replace with your job name
    SET start_time = NOW();

    -- Your logic for the stored procedure goes here
    -- ...

    -- Set end time based on the success or failure of the procedure
    IF YourProcedureLogicIsSuccessful() THEN
        SET end_time = NOW();
        SET job_status = 'SUCCESS';
        SET job_details = 'Procedure executed successfully.';
    ELSE
        SET end_time = NOW();
        SET job_status = 'FAILURE';
        SET job_details = 'Procedure execution failed.';
    END IF;

    -- Insert job details into the job table
    INSERT INTO job (job_name, start_time, end_time, status, details)
    VALUES (job_name, start_time, end_time, job_status, job_details);
END //

DELIMITER ;



CREATE TABLE job_execution (
    job_id INT AUTO_INCREMENT PRIMARY KEY,
    job_name VARCHAR(255) NOT NULL,
    start_time DATETIME NOT NULL,
    end_time DATETIME,
    status ENUM('RUNNING', 'SUCCESS', 'FAILURE') DEFAULT 'RUNNING',
    details TEXT,
    -- Add any additional columns as needed
    INDEX idx_start_time (start_time),
    INDEX idx_end_time (end_time),
    INDEX idx_status (status)
);


DATE_SUB(CURDATE(), INTERVAL 1 DAY)

DATE_SUB(CURDATE(), INTERVAL 1 SECOND)

DELIMITER //

CREATE PROCEDURE FetchDayBeforeRecords()
BEGIN
    DECLARE yesterday_start DATETIME;
    DECLARE yesterday_end DATETIME;

    -- Calculate start of yesterday (00:00:00)
    SET yesterday_start = DATE_SUB(NOW(), INTERVAL 1 DAY);

    -- Calculate end of yesterday (23:59:59)
    SET yesterday_end = DATE_SUB(NOW(), INTERVAL 1 SECOND);

    -- Now you can use the yesterday_start and yesterday_end variables in your query
    SELECT *
    FROM your_table
    WHERE your_datetime_column BETWEEN yesterday_start AND yesterday_end;

END //

DELIMITER ;


DELIMITER //

CREATE PROCEDURE FetchRecordsForDateRange(IN input_date DATE)
BEGIN
    DECLARE start_date DATE;
    DECLARE end_date DATE;

    -- Calculate start date (input_date - 1 day)
    SET start_date = DATE_SUB(input_date, INTERVAL 1 DAY);

    -- Set end date to the input_date
    SET end_date = input_date;

    -- Now you can use the start_date and end_date variables in your query
    SELECT *
    FROM your_table
    WHERE your_date_column BETWEEN start_date AND end_date;

END //

DELIMITER ;



SELECT *
FROM your_table
WHERE your_date_column < CURDATE();

SELECT *
FROM your_table
WHERE your_date_column = DATE_SUB(CURDATE(), INTERVAL 1 DAY);

DECLARE result_date DATE;

    -- Subtract 1 day from the input date
    SET result_date = DATE_SUB(input_date, INTERVAL 1 DAY);

-- Add the last partition with MAXVALUE
    SET @sql = CONCAT(@sql, 'PARTITION p', current_year, ' VALUES LESS THAN MAXVALUE);');

DELIMITER //

CREATE PROCEDURE your_procedure()
BEGIN
    -- Declare variables
    DECLARE combinedyearmonth VARCHAR(7);

    -- Set the combined year and month value
    SET combinedyearmonth = CONCAT(YEAR(NOW()), '-', LPAD(MONTH(NOW()), 2, '0'));

    -- Create a temporary table with the combined year and month value
    CREATE TEMPORARY TABLE temp_table AS (
        SELECT 
            your_table.*,
            combinedyearmonth AS year_month_combined
        FROM 
            your_table
    );

    -- Use the temporary table in your further logic
    SELECT * FROM temp_table;

    -- Drop the temporary table when done
    DROP TEMPORARY TABLE IF EXISTS temp_table;
END //

DELIMITER ;



ALTER TABLE your_table
ADD PARTITION (
    PARTITION p_before_2024 VALUES LESS THAN (TO_DAYS('2024-01-01'))
);
Add Monthly Partitions Starting from 2024:

DELIMITER //

CREATE PROCEDURE AddMonthlyPartitions()
BEGIN
    DECLARE i INT DEFAULT 1;

    WHILE i <= 12 DO
        SET @sql = CONCAT('ALTER TABLE your_table ADD PARTITION (PARTITION p_', DATE_FORMAT('2024-01-01', '%Y%m'), 
                          ' VALUES LESS THAN (', TO_DAYS('2024-01-01' + INTERVAL i MONTH), '))');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;

        SET i = i + 1;
    END WHILE;
END //

DELIMITER ;

-- Execute the stored procedure to add partitions for the next 12 months starting from 2024
CALL AddMonthlyPartitions();



ALTER TABLE your_table
ADD PARTITION (
    PARTITION p_next_month VALUES LESS THAN (TO_DAYS(NOW()) + 32)
);

SELECT * FROM your_table
WHERE
    YEAR(date_column) = your_year
    AND MONTH(date_column) = your_month;


CREATE TABLE your_table (
    id INT,
    date_column DATE,
    -- other columns...
) PARTITION BY RANGE COLUMNS (YEAR(date_column), MONTH(date_column)) (
    PARTITION p0 VALUES LESS THAN (2000, 1),
    PARTITION p1 VALUES LESS THAN (2000, 2),
    PARTITION p2 VALUES LESS THAN (2000, 3),
    -- Continue creating partitions for each year and month combination
    PARTITION p_max VALUES LESS THAN (MAXVALUE, MAXVALUE)
);



CREATE TABLE your_table (
   -- columns...
) PARTITION BY RANGE (YEAR(date_column)) (
   PARTITION p0 VALUES LESS THAN (1991),
   PARTITION p1 VALUES LESS THAN (1992),
   ...
);


SELECT JSON_UNQUOTE(JSON_EXTRACT(data3, '$[0]')) AS result
FROM efr2;
["ADCBCCSSO"]
consider your annual leave plans for the upcoming year.
select JSON_UNQUOTE(JSON_EXTRACT(data2, '$."x-channel-id"')) from efr2;

JSON_UNQUOTE(JSON_EXTRACT(your_longtext_column, '$.`key-with-hyphen`')) AS extracted_value

[X-Request-ID:"d8e18241-ec69-49af-a986-7f1703574c15", X-Channel-ID:"5", x-fapi-interaction-id:"3ccaee28-0d1f-3898-adf4-c5c37ddd7a3e"]

{"authorization":["Basic ZGV2OmRldjEyMw=="],"x-channel-id":["ADCBCCSSO"],"x-fapi-interaction-id":["0002d15e-8609-3942-a1df-c58335e9d314"],"content-type":["application/json; charset=utf-8"],"content-length":["68"],"host":["10.101.166.114:9085"],"connectio...

JSON_UNQUOTE(JSON_EXTRACT(your_longtext_column, '$[?(@.key2)]')) AS extracted_value

SELECT *
FROM your_table
WHERE JSON_EXTRACT(your_longtext_column, '$.your_key') = 'your_value';


CALL FetchDataByDateRange('2024-01-01', '2024-01-31');

DELIMITER //

CREATE PROCEDURE FetchDataByDateRange(
    IN start_date DATE,
    IN end_date DATE
)
BEGIN
    WITH CTE_Table1 AS (
        SELECT 
            column1 AS t1_col1,
            column2 AS t1_col2,
            date_column AS t1_date
        FROM 
            table1
        WHERE 
            date_column BETWEEN start_date AND end_date
    ),
    
    CTE_Table2 AS (
        SELECT 
            column3 AS t2_col1,
            column4 AS t2_col2,
            date_column AS t2_date
        FROM 
            table2
        WHERE 
            date_column BETWEEN start_date AND end_date
    ),
    
    CombinedData AS (
        SELECT 
            t1.t1_col1,
            t1.t1_col2,
            t1.t1_date,
            t2.t2_col1,
            t2.t2_col2,
            t2.t2_date
        FROM 
            CTE_Table1 t1
        JOIN 
            CTE_Table2 t2 ON t1.t1_date = t2.t2_date
    )
    
    SELECT * FROM CombinedData;
    
END //

DELIMITER ;




DELIMITER //

CREATE PROCEDURE FetchDataByDateRange(
    IN start_date DATE,
    IN end_date DATE
)
BEGIN
    WITH CombinedData AS (
        SELECT 
            table1.*, 
            table2.*
        FROM 
            table1
        JOIN 
            table2 ON table1.common_column = table2.common_column  -- Replace with the actual common column
        WHERE 
            table1.date_column BETWEEN start_date AND end_date
            AND table2.date_column BETWEEN start_date AND end_date
    )
    
    SELECT * FROM CombinedData;
    
END //

DELIMITER ;
