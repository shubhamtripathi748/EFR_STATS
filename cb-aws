The diagram below illustrates the AWS-based document management architecture, highlighting key services such as API Gateway, Lambda, S3, and DynamoDB.

1. Overview
Purpose: High-level summary of the AWS architecture, its objectives, and how it supports document management.

2. Architecture Diagram
Purpose: Visual representation of the end-to-end architecture, including API Gateway, Lambda, S3, DynamoDB, Direct Connect, and API Connect.

3. AWS Services and Components
Purpose: Breakdown of key AWS services used and their roles in the architecture. Example:

API Gateway – Exposes RESTful APIs for document operations.
AWS Lambda – Serverless compute for CRUD operations.
Amazon S3 – Storage for document binaries.
Amazon DynamoDB – Metadata storage for documents.
AWS Direct Connect – Secure on-prem to AWS connectivity.
IAM Roles & Security – Access control mechanisms.




Short-term (Day 1): Implement a simple GET API that retrieves documents by aws_guid from DynamoDB and fetches the S3 URL.
Future Enhancement (Search API):
Use DynamoDB Global Secondary Indexes (GSIs) on fields like user_id, file_name, and upload_date to enable efficient search.
Implement a query-based Lambda function that allows filtering based on multiple metadata fields.
If full-text search is needed, consider integrating Amazon OpenSearch (Elasticsearch) for advanced searching.




aws_guid → Generate and map AWS GUIDs for existing records.
Use migration_status for tracking → Helps manage and troubleshoot migration.



Category	Decision Explanation
Security Risk	To mitigate security risks, IAM policies and role-based access control (RBAC) will be enforced to limit access to S3 and DynamoDB. Data encryption (both in transit using TLS and at rest using AWS KMS) will be enabled to protect sensitive documents. AWS VPC Endpoints will be used to prevent data exposure over the internet.
Performance Bottlenecks	To ensure high performance, S3 Multipart Upload will be used for large files, and DynamoDB Global Tables will be enabled to distribute metadata across multiple regions if needed. API Gateway and Lambda concurrency settings will be optimized to handle peak loads efficiently. CloudFront will be used for caching frequently accessed files.
Fault Tolerance and Resiliency	The solution will leverage multi-AZ S3 storage, ensuring high availability. DynamoDB offers built-in fault tolerance with replication across multiple Availability Zones (AZs). AWS Lambda retries will be configured, and AWS Step Functions can handle complex workflows with built-in retries and error handling.
Monitoring and Observability	AWS CloudWatch Logs and Metrics will be enabled to monitor API Gateway, Lambda, S3, and DynamoDB performance. AWS X-Ray will be used for distributed tracing. CloudTrail logging will track access to S3 and DynamoDB for security audits. Real-time alerts via Amazon SNS will notify stakeholders of failures.
Compliance and Retention Policies	S3 Object Lifecycle Policies will be enforced to automatically archive or delete documents based on regulatory requirements. AWS Config and Audit Manager will be used for compliance tracking. Data versioning and WORM (Write Once Read Many) policies can be applied to meet industry-specific regulations.





During the initial requirement gathering discussions, it was identified that the organization needs to migrate approximately 6TB of data to Amazon S3. This significant data volume presents several architectural and operational considerations, including data transfer strategy, performance optimization, cost management, and security compliance.


Revised Key Objective Statement
One of the key objectives of this solution is to establish a new, scalable service that enables efficient and secure document management for document binaries outside of i-Prompt. This service will support seamless storage, retrieval, and metadata management, ensuring high availability, interoperability, and compliance with security and access control policies. For a detailed breakdown of the architectural considerations and implementation strategy, refer to Appendix A.

Appendix A: Detailed Breakdown of Document Management Service
1. Need for a Separate Document Management Service
i-Prompt currently serves as a document repository but may have limitations in scalability, accessibility, or integration with external systems.
A dedicated service ensures that document binaries can be managed independently of i-Prompt, supporting new use cases without architectural constraints.
2. Architectural Considerations
Storage: S3 for secure, scalable document storage.
Metadata: DynamoDB for fast lookup of document details (GUID, S3 URL, timestamps).
Access Control: IAM-based security to define granular access.
API Integration: REST APIs via API Gateway & Lambda for CRUD operations.
Scalability: Fully serverless model to handle dynamic workloads efficiently.
3. Key Features & Benefits
✅ Multi-service access: Allows multiple applications to interact with the document storage system.
✅ Improved Performance: Optimized for fast retrieval and querying.
✅ Security & Compliance: Ensures proper access control and encryption at rest & transit.
✅ Future-Ready: Designed to support future enhancements like AI-based search, tagging, and retention policies.







One of the key objectives should be to establish a new, scalable service that enables efficient and secure document management for document binaries outside of i-Prompt. This service should provide seamless storage, retrieval, and metadata management, ensuring high availability, interoperability, and compliance with security and access control policies. It should be designed to support multiple consumers, integrate with AWS-native services, and facilitate future enhancements such as advanced search, tagging, and lifecycle management.

✅ Fast, scalable, and serverless for CRUD operations.
✅ Lower cost with on-demand pricing compared to RDS.
✅ Seamless AWS integration (IAM, API Gateway, Lambda, and S3).
✅ Schema flexibility makes it easy to evolve over time.



For your architecture (API Gateway → Lambda → S3/DynamoDB):
✅ Python is ideal due to fast cold starts, lower memory usage, and AWS SDK support.
✅ Node.js is also a good choice if you have event-driven, high-concurrency workloads.
❌ Java is less optimal unless you have long-running, CPU-heavy processes.



Dear [Senior’s Name],

I hope you are doing well.

I have created/modified the IT Architecture Design page, the Solution Context page, and their respective child pages. Please review them and confirm if they align with expectations. If everything looks good, I will proceed with updating the remaining documentation accordingly.

Your feedback would be greatly appreciated. Please let me know if any modifications or clarifications are needed.

Looking forward to your response.



---------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<mxGraphModel dx="1040" dy="668" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
  <root>
    <mxCell id="0" />
    <mxCell id="1" parent="0" />
    
    <!-- On-Premises Components -->
    <mxCell id="2" value="Spring Batch (On-Prem)" style="shape=ellipse;fillColor=#D9EAD3;" vertex="1" parent="1">
      <mxGeometry x="50" y="100" width="140" height="60" as="geometry" />
    </mxCell>
    <mxCell id="3" value="Oracle Database" style="shape=cylinder;fillColor=#F3F3F3;" vertex="1" parent="1">
      <mxGeometry x="50" y="200" width="140" height="80" as="geometry" />
    </mxCell>
    <mxCell id="4" value="API Connect (On-Prem)" style="shape=rectangle;fillColor=#EAD1DC;" vertex="1" parent="1">
      <mxGeometry x="50" y="320" width="140" height="60" as="geometry" />
    </mxCell>
    <mxCell id="5" value="AWS Direct Connect" style="shape=hexagon;fillColor=#CFE2F3;" vertex="1" parent="1">
      <mxGeometry x="250" y="320" width="140" height="60" as="geometry" />
    </mxCell>
    
    <!-- AWS Components -->
    <mxCell id="6" value="AWS API Gateway" style="shape=rectangle;fillColor=#FFF2CC;" vertex="1" parent="1">
      <mxGeometry x="450" y="320" width="140" height="60" as="geometry" />
    </mxCell>
    <mxCell id="7" value="AWS Lambda (Create)" style="shape=rectangle;fillColor=#D5A6BD;" vertex="1" parent="1">
      <mxGeometry x="650" y="320" width="140" height="60" as="geometry" />
    </mxCell>
    <mxCell id="8" value="Amazon S3 (Document Storage)" style="shape=rectangle;fillColor=#B4A7D6;" vertex="1" parent="1">
      <mxGeometry x="850" y="270" width="140" height="60" as="geometry" />
    </mxCell>
    <mxCell id="9" value="Amazon DynamoDB (Metadata Storage)" style="shape=rectangle;fillColor=#76A5AF;" vertex="1" parent="1">
      <mxGeometry x="850" y="370" width="140" height="60" as="geometry" />
    </mxCell>
    
    <!-- Returning GUID -->
    <mxCell id="10" value="Returning GUID to On-Prem" style="edgeStyle=elbowEdgeStyle;strokeColor=#000000;" edge="1" parent="1" source="7" target="4">
      <mxGeometry relative="1" as="geometry" />
    </mxCell>
    <mxCell id="11" value="Store GUID Back to Oracle" style="edgeStyle=elbowEdgeStyle;strokeColor=#000000;" edge="1" parent="1" source="4" target="3">
      <mxGeometry relative="1" as="geometry" />
    </mxCell>
    
    <!-- Data Flow -->
    <mxCell id="12" value="" style="edgeStyle=elbowEdgeStyle;strokeColor=#000000;" edge="1" parent="1" source="2" target="3">
      <mxGeometry relative="1" as="geometry" />
    </mxCell>
    <mxCell id="13" value="" style="edgeStyle=elbowEdgeStyle;strokeColor=#000000;" edge="1" parent="1" source="3" target="4">
      <mxGeometry relative="1" as="geometry" />
    </mxCell>
    <mxCell id="14" value="" style="edgeStyle=elbowEdgeStyle;strokeColor=#000000;" edge="1" parent="1" source="4" target="5">
      <mxGeometry relative="1" as="geometry" />
    </mxCell>
    <mxCell id="15" value="" style="edgeStyle=elbowEdgeStyle;strokeColor=#000000;" edge="1" parent="1" source="5" target="6">
      <mxGeometry relative="1" as="geometry" />
    </mxCell>
    <mxCell id="16" value="" style="edgeStyle=elbowEdgeStyle;strokeColor=#000000;" edge="1" parent="1" source="6" target="7">
      <mxGeometry relative="1" as="geometry" />
    </mxCell>
    <mxCell id="17" value="" style="edgeStyle=elbowEdgeStyle;strokeColor=#000000;" edge="1" parent="1" source="7" target="8">
      <mxGeometry relative="1" as="geometry" />
    </mxCell>
    <mxCell id="18" value="" style="edgeStyle=elbowEdgeStyle;strokeColor=#000000;" edge="1" parent="1" source="7" target="9">
      <mxGeometry relative="1" as="geometry" />
    </mxCell>
  </root>
</mxGraphModel>













Final Flow (Updated)
Spring Batch (On-Premises)

Queries Oracle DB for documents.
Calls API Connect (On-Prem).
API Connect (On-Premises)

Routes request via Direct Connect to AWS API Gateway.
AWS API Gateway

Triggers AWS Lambda (Create Function).
AWS Lambda (Create Function)

Stores document in S3.
Saves GUID, S3 path, timestamp in DynamoDB.
Returns GUID back to API Connect.
API Connect (On-Premises)

Sends GUID to Spring Batch.
Spring Batch

Updates Oracle Database with GUID.
Lucidchart Enhancements
Add a new arrow from AWS Lambda → API Connect (Return GUID).
Add an arrow from API Connect → Spring Batch.
Add an arrow from Spring Batch → Oracle DB (Store GUID).




Serverless design using AWS: API Gateway routes requests to separate Lambda functions for each CRUD operation. S3 stores documents, and DynamoDB (on-demand) holds metadata (S3 URL, GUID, date). Integrated with on-prem API Connect.


PI Management Documentation
1. Overview
This document provides an overview of API management for document CRUD operations using API Connect (API-C) on-premises and AWS API Gateway. It covers API endpoints, authentication, request/response formats, and integration with AWS services.

2. Architecture
On-Premises: API-C routes requests from internal applications to AWS.
AWS:
API Gateway with separate endpoints for CRUD operations
Direct Connect for secure communication between API-C and AWS
Separate AWS Lambda functions for each operation
S3 for document storage
DynamoDB for metadata storage (GUID, date, S3 URL)
3. API Endpoints & Methods
Operation	HTTP Method	On-Prem API-C Endpoint	AWS API Gateway Endpoint	Description
Create	POST	/api/documents	/documents	Uploads a new document, generates a GUID, and stores it in S3 and DynamoDB.
Read Metadata	GET	/api/documents/{guid}	/documents/{guid}	Retrieves document metadata from DynamoDB.
Download	GET	/api/documents/{guid}/download	/documents/{guid}/download	Generates a pre-signed URL to download the document from S3.
Update Metadata	PUT	/api/documents/{guid}	/documents/{guid}	Updates metadata of an existing document.
Delete	DELETE	/api/documents/{guid}	/documents/{guid}	Deletes the document from S3 and removes metadata from DynamoDB.
4. Request & Response Format
(A) Create Document (POST /documents)
Request:

json
Copy
Edit
{
  "file_name": "document.pdf",
  "metadata": {
    "author": "John Doe",
    "category": "Legal"
  }
}
Response:

json
Copy
Edit
{
  "guid": "abc123",
  "status": "success"
}
(B) Get Document Metadata (GET /documents/{guid})
Response:

json
Copy
Edit
{
  "guid": "abc123",
  "s3_url": "s3://my-bucket/document.pdf",
  "uploaded_at": "2025-02-11T12:00:00Z"
}
5. Security & Authentication
API-C enforces authentication before routing requests to AWS API Gateway.
API Gateway uses IAM roles and JWT-based authentication (e.g., Cognito).
S3 pre-signed URLs ensure secure document access.
6. Error Handling & Retry Mechanism
Exception	HTTP Status Code	Description
Invalid request payload	400	Request body is malformed or missing parameters.
Unauthorized access	401	API request lacks valid credentials.
Document not found	404	Requested document does not exist.
S3 upload failure	500	AWS S3 failed to store the document.
Direct Connect failure	502	Network issue between on-prem and AWS.
7. Logging & Monitoring
CloudWatch Logs for API Gateway & Lambda execution monitoring.
AWS X-Ray for tracing API calls across services.
API-C Logging for on-prem API request tracking.
Would you like me to format this as a Confluence-compatible markdown file for direct upload? 🚀






You said:
i need interface metrix with from,OT,protocol,description as header and all functions(for e.g create) with header function,method URI AND DESCRIPTION
ChatGPT said:
Here's your Interface Matrix and API Function Details in table format for documentation in Confluence.

1. Interface Matrix
From	To	Protocol	Description
Application	API-C (On-Prem)	HTTPS	Application sends requests to API Connect.
API-C (On-Prem)	AWS API Gateway	HTTPS	API-C routes requests to AWS API Gateway over Direct Connect.
AWS API Gateway	AWS Lambda	HTTPS	API Gateway triggers the corresponding Lambda function for CRUD operations.
AWS Lambda	S3	HTTPS	Lambda stores or retrieves documents in S3.
AWS Lambda	DynamoDB	HTTPS	Lambda stores or updates document metadata in DynamoDB.
AWS Lambda	API Gateway	HTTPS	Lambda returns responses to API Gateway.
API Gateway	API-C (On-Prem)	HTTPS	API Gateway sends responses back to API-C.
API-C (On-Prem)	Application	HTTPS	API-C forwards the response to the calling application.
2. API Function Details
Function	Method	URI	Description
Create Document	POST	/documents	Uploads a new document, generates a GUID, and stores it in S3 & DynamoDB.
Read Document Metadata	GET	/documents/{guid}	Retrieves metadata (S3 URL, timestamp) for a given document.
Download Document	GET	/documents/{guid}/download	Generates a pre-signed URL to download the document from S3.
Update Document Metadata	PUT	/documents/{guid}	Updates the metadata of an existing document.
Delete Document	DELETE	/documents/{guid}	Deletes the document from S3 and removes metadata from DynamoDB.
List All Documents	GET	/documents	Retrieves a paginated list of all stored documents.
Would you like this in Confluence-compatible markdown or CSV format for easy upload? 🚀






You said:
DOWNLAOD last 2 answer in .docx format
ChatGPT said:
I have generated a Word document containing the Interface Matrix and API Function Details. You can download it using the link below:

📥 Download API_Interface_Matrix.docx






You said:
not able to download last two result docx file
ChatGPT said:
I'll regenerate the Word document containing both the Interface Matrix and API Function Details for you. Let me create the file again.

You can download the Word document containing the Interface Matrix and API Function Details using the link below:










Method	URI	Description
POST	/documents	Uploads a new document (returns GUID).
GET	/documents/{guid}	Retrieves document metadata by GUID.
PUT	/documents/{guid}	Updates document metadata (e.g., tags, descriptions).
DELETE	/documents/{guid}	Deletes a document and its metadata.





Design Decisions & Rationale for Upload New Document Service
The document upload service is designed with security, scalability, reliability, and cost-efficiency in mind. Below are key design decisions and the rationale behind each.

1. Architecture Selection: Serverless (API Gateway + Lambda + S3 + DynamoDB)
✅ Design Decision: Use API Gateway, Lambda, S3, and DynamoDB instead of EC2-based services.
💡 Rationale:

Serverless autoscaling eliminates the need for infrastructure management.
Pay-per-use pricing optimizes cost (Lambda runs only when triggered).
Seamless integration with AWS native services (S3, DynamoDB).
High availability & fault tolerance with AWS-managed services.
2. Data Storage: S3 for Documents, DynamoDB for Metadata
✅ Design Decision: Store documents in S3 and metadata in DynamoDB rather than keeping both in a database.
💡 Rationale:

S3 optimized for large object storage with built-in durability (99.999999999% reliability).
DynamoDB provides fast metadata access with scalable, low-latency lookups.
Separation of concerns: Keeping metadata in a DB prevents expensive queries on S3.
3. Security: IAM Policies & Encryption
✅ Design Decision: Use IAM role-based access control and S3 Server-Side Encryption (SSE-KMS).
💡 Rationale:

Least privilege access ensures only specific Lambda functions can access S3 & DynamoDB.
Encryption at rest protects document data from unauthorized access.
VPC Gateway Endpoints for S3/DynamoDB ensure private communication (no exposure to the public internet).
4. API Gateway & Lambda for Stateless Processing
✅ Design Decision: API Gateway invokes separate Lambda functions for each operation (Upload, Read, Update, Delete).
💡 Rationale:

Stateless Lambda functions improve modularity and fault isolation.
Decoupling of business logic allows independent scaling of functions.
Automatic retries for transient failures (network errors, S3 upload issues).
5. Unique Identifier (GUID) for Document Tracking
✅ Design Decision: Generate a GUID instead of using filenames or database auto-increment IDs.
💡 Rationale:

Ensures uniqueness even across multiple AWS regions.
Prevents conflicts in concurrent document uploads.
Eases tracking & indexing in DynamoDB.
6. Failure Handling & Retries
✅ Design Decision: Implement retry logic and store migration status in Oracle for tracking.
💡 Rationale:

Retries reduce transient failures (e.g., temporary S3/DynamoDB issues).
Migration tracking in Oracle allows auditability of failed records.
Dead-letter queue (DLQ) for failed requests enables manual reprocessing if needed.
7. Performance Optimization: Multipart Upload for Large Files
✅ Design Decision: Use S3 Multipart Upload API for files >5MB.
💡 Rationale:

Faster uploads by breaking files into chunks and uploading in parallel.
Resumability ensures failure recovery for large files.
Reduces API Gateway & Lambda timeout risks for large document uploads.
8. Cost Optimization: On-Demand Services
✅ Design Decision: Use on-demand billing for DynamoDB and Lambda instead of provisioned capacity.
💡 Rationale:

Minimizes AWS costs by scaling resources based on actual traffic.
Avoids over-provisioning during low usage periods.
DynamoDB auto-scaling handles dynamic workloads efficiently.
Conclusion
The chosen design prioritizes security, scalability, reliability, and cost-efficiency while ensuring seamless integration with both on-premises systems and AWS services.





The Upload New Document service enables an application to securely store documents in AWS S3 and maintain metadata in DynamoDB. It follows a serverless architecture, using API Gateway, AWS Lambda, S3, and DynamoDB to ensure scalability, security, and reliability.


Service Flow & Steps
Step No.	Component	Action	Description
1	Application (On-Premises or Cloud)	Initiate Upload Request	Sends a document and metadata to API-C (On-Premises API Gateway) over HTTPS.
2	API-C (On-Premises)	Forward Request to AWS	Forwards the document and metadata to AWS API Gateway over HTTPS.
3	AWS API Gateway	Invoke Upload Lambda	Validates request and triggers AWS Lambda (CreateDocument Function).
4	AWS Lambda (CreateDocument Function)	Generate GUID	Generates a GUID (Unique Identifier) for tracking.
5	AWS Lambda → API Gateway Endpoint (S3)	Upload Document to S3	Calls S3 API to store the document and receives the S3 URL.
6	S3	Store Document	The document is saved in an S3 bucket with encryption enabled.
7	AWS Lambda → API Gateway Endpoint (DynamoDB)	Store Metadata in DynamoDB	Saves the document metadata (GUID, S3 URL, timestamps, etc.) in DynamoDB.
8	AWS API Gateway	Return Response	Returns GUID & success status to API-C (On-Premises).
9	API-C (On-Premises)	Confirm Upload	Updates the migration status in Oracle (if applicable) and notifies the application.
Service Features & Considerations
🔹 Security:
✅ HTTPS for secure data transfer.
✅ IAM roles & policies to restrict access to S3 and DynamoDB.
✅ Server-Side Encryption (S3 SSE-KMS or SSE-S3) for document security.

🔹 Scalability & Performance:
✅ Multipart Uploads for large file handling.
✅ On-Demand Lambda & DynamoDB Billing to handle variable workloads.
✅ VPC Gateway Endpoints for S3 & DynamoDB to avoid public internet exposure.

🔹 Reliability & Failure Handling:
✅ Retry Mechanism (for S3 upload, DynamoDB write failures).
✅ API Rate Limiting & Throttling (to prevent overload).
✅ Logging & Monitoring via CloudWatch & X-Ray.

Final Output
📌 Success Response:

GUID (Unique Identifier)
S3 URL (for document retrieval)
HTTP 200 (Success)
📌 Failure Handling:

Retry on transient failures (S3, DynamoDB errors)
Fallback to logging & manual reprocessing for failed documents













Invalid API Request	API-C sends malformed or unauthorized request to API Gateway	API-C → API Gateway	400 (Bad Request) / 403 (Forbidden)
Authentication Failure	API request missing or incorrect IAM credentials	API-C → API Gateway	401 (Unauthorized)
Rate Limit Exceeded	API Gateway rate limits exceeded due to high migration load	API-C → API Gateway	429 (Too Many Requests)
Lambda Invocation Failure	AWS Lambda execution error due to internal issue	API Gateway → Lambda	500 (Internal Server Error)
S3 Upload Failure	Document failed to upload to S3 (e.g., timeout, permission issue)	Lambda → API Gateway Endpoint (S3) → S3	500 (Internal Server Error)
S3 Multipart Upload Failure	Large document upload fails mid-transfer	Lambda → S3	500 (Internal Server Error)
DynamoDB Write Failure	Metadata storage failure due to capacity limits or table issues	Lambda → API Gateway Endpoint (DynamoDB) → DynamoDB	500 (Internal Server Error)
Network Timeout	API Gateway request to Lambda/S3/DynamoDB takes too long and times out	API Gateway → Lambda/S3/DynamoDB	504 (Gateway Timeout)
Database Connection Failure	Oracle DB not reachable from API-C or migration job	API-C → Oracle	500 (Internal Server Error)
GUID Generation Error	GUID creation fails due to unexpected Lambda execution issue	Lambda	500 (Internal Server Error)
Validation Failure	Validation step fails (S3 document not found, metadata mismatch)	On-Prem Validation Job → API Gateway → DynamoDB	404 (Not Found)
Retry Exhausted	Multiple retries failed, marking migration as permanently failed	Retry Handler	No HTTP Code (Logged for tracking)
VPC Endpoint Connectivity Failure	API Gateway Endpoint cannot reach S3 or DynamoDB due to misconfiguration	API Gateway Endpoint → S3/DynamoDB	503 (Service Unavailable)
Circuit Breaker Triggered	API-C prevents excessive retries due to continuous failures	API-C	No HTTP Code (Logged and flagged)
Key Takeaways
Client-Side Errors (4xx): Authentication, authorization, rate limits, invalid requests
Server-Side Errors (5xx): Failures in AWS services, Lambda execution, S3/DynamoDB issues
Retries & Timeouts: Built-in retry logic for transient failures (S3/DynamoDB updates)









Sequential Order of Processing: Document Migration from On-Premises to AWS
The migration follows a step-by-step sequence ensuring secure transfer, metadata storage, and validation. Below is the exact order of processing:

1. Extraction from On-Premises
✅ Step 1: Spring Scheduler Job (On-Premises) triggers the migration process at scheduled intervals.
✅ Step 2: The scheduler extracts document data and metadata from the on-prem file system or database.
✅ Step 3: The extracted document and metadata are sent to API-C (On-Premises API Gateway) over HTTPS.

2. Secure Transfer to AWS
✅ Step 4: API-C forwards the request to AWS API Gateway (exposed via HTTPS).
✅ Step 5: AWS API Gateway validates the request and forwards it to the appropriate AWS Lambda function.
✅ Step 6: Lambda (CreateDocument function) processes the request and generates a GUID (Unique Identifier) for tracking.

3. Uploading Document to AWS S3
✅ Step 7: Lambda calls the API Gateway Endpoint for S3, which ensures a secure transfer.
✅ Step 8: The document is uploaded to S3 and a pre-signed S3 URL is generated.

4. Storing Metadata in DynamoDB
✅ Step 9: Lambda calls the API Gateway Endpoint for DynamoDB.
✅ Step 10: The document metadata (GUID, S3 URL, timestamps) is stored in DynamoDB.

5. Acknowledgment & Status Update
✅ Step 11: Lambda sends a response back to API Gateway, containing the GUID and success status.
✅ Step 12: API Gateway forwards the response to API-C (On-Premises Gateway).
✅ Step 13: API-C updates the migration status in the on-prem database (Oracle, if applicable).

6. Post-Migration Validation
✅ Step 14: On-premises system verifies if the migrated document exists in S3 by checking DynamoDB records.
✅ Step 15: If validation is successful, the migration status in Oracle is updated to SUCCESS.
✅ Step 16: If validation fails, a retry mechanism is triggered or an alert is raised for manual intervention.

7. Error Handling & Retry Mechanism
🔄 Step 17: If any failure occurs in S3 upload or DynamoDB update:

Retry up to 3 times with exponential backoff.
If all retries fail, the failure is logged for manual resolution.
Migration status in Oracle is marked as FAILED, and the document is queued for reattempt.
Final Process Flow Summary
mathematica
Copy
Edit
1️⃣ Extract document → 2️⃣ API-C (On-Prem) → 3️⃣ AWS API Gateway → 4️⃣ AWS Lambda  
5️⃣ Upload to S3 → 6️⃣ Store Metadata in DynamoDB → 7️⃣ Return GUID & Status  
8️⃣ Update On-Prem Migration Table → 9️⃣ Validate Document in S3 →  🔟 Mark Success/Failure






















This service facilitates the migration of documents from an on-premises environment to AWS, leveraging API Gateway, AWS Lambda, S3, and DynamoDB. It ensures a secure, scalable, and automated process for transferring and managing documents in AWS.



Service Components & Flow
1. Source (On-Premises)
Application & API-C: The on-premises system initiates the migration.
Spring Scheduler Job: Automates the migration process by triggering API calls at scheduled intervals.
Existing Document Storage: Documents reside in on-prem file servers or databases before migration.
2. Migration Process
Step 1: Document Extraction

Spring Scheduler extracts document data and metadata from the source system.
Calls API-C (On-Premises Gateway) to initiate the migration request.
Step 2: Secure Transfer via API Gateway

API-C forwards the request to AWS API Gateway over HTTPS.
API Gateway invokes the AWS Lambda "CreateDocument" function for processing.
Step 3: Upload to S3

Lambda generates a GUID for document tracking.
Document is uploaded to S3 via API Gateway Endpoint.
The S3 URL is generated for retrieval.
Step 4: Metadata Storage in DynamoDB

Lambda stores document metadata (GUID, S3 URL, timestamps) in DynamoDB using API Gateway Endpoint.
Step 5: Acknowledgment & Status Update

Success Response: GUID is returned to API-C and the on-prem system updates the migration status.
Failure Handling: If migration fails, retries occur. If all retries fail, the failure is logged in Oracle (if tracking is enabled).
3. AWS Services Used
AWS Service	Role in Migration
API Gateway	Securely exposes endpoints for document migration.
AWS Lambda	Processes requests, handles GUID generation, and interacts with S3 & DynamoDB.
S3	Stores migrated documents securely.
DynamoDB	Stores document metadata (GUID, S3 URL, timestamps).
API Gateway Endpoint	Ensures private, fast access to S3 and DynamoDB without traversing the internet.
4. Error Handling & Retry Strategy
DynamoDB Update Failure → Retry up to 3 times (exponential backoff).
S3 Upload Failure → Retry via API Gateway, log errors in CloudWatch.
API-C/AWS Communication Issues → Implement circuit breaker pattern & fallback mechanism.
5. Security Considerations
IAM Policies → Enforce least privilege access for Lambda & API Gateway.
Data Encryption → Documents stored in S3 are encrypted (SSE-S3/KMS).
VPC Endpoints → API Gateway Endpoints used for private S3/DynamoDB access.
6. Post-Migration Validation
Scheduled job compares Oracle Migration Status Table (on-prem) with DynamoDB entries to ensure data consistency.
API for validating document availability in S3 before marking migration as complete.




To handle failed status in the database update flow, we need to introduce a retry mechanism. This ensures that if updating the metadata in DynamoDB fails, the system will retry a few times before marking the operation as failed.

Key Additions:
✔ Retry Logic: Introduced up to 3 retries in case metadata update fails.
✔ Failure Handling: If retries fail, the system logs the failure and stores a FAILED status.
✔ Seamless Recovery: If retry succeeds, the operation completes as us



An Interface Matrix is used to document the communication between different components in your architecture. Since you're using API Gateway, Lambda, and DynamoDB for CRUD operations and have on-premises components like Migration Service and API-C, here’s how you can structure your Interface Matrix:
Now, all S3 and DynamoDB interactions happen through API Gateway Endpoints, ensuring secure and controlled access. 




On-Premises Migration Service	API-C	HTTPS	Migration service calls API-C for data processing before integration.
API-C	AWS API Gateway	HTTPS	API-C sends document CRUD requests to API Gateway.
AWS API Gateway	AWS Lambda (CRUD functions)	HTTPS	API Gateway triggers the appropriate Lambda function for CRUD operations.
AWS Lambda (Create Function)	API Gateway Endpoint for S3	HTTPS	Lambda uploads the document to S3 via API Gateway Endpoint.
AWS Lambda (Create Function)	API Gateway Endpoint for DynamoDB	HTTPS	Lambda stores document metadata (GUID, S3 URL) in DynamoDB via API Gateway Endpoint.
AWS Lambda (Read Function)	API Gateway Endpoint for DynamoDB	HTTPS	Lambda retrieves metadata for requested documents via API Gateway Endpoint.
AWS Lambda (Read Function)	API Gateway Endpoint for S3	HTTPS	Lambda fetches document from S3 via API Gateway Endpoint.
AWS Lambda (Update Function)	API Gateway Endpoint for DynamoDB	HTTPS	Lambda updates document metadata in DynamoDB via API Gateway Endpoint.
AWS Lambda (Update Function)	API Gateway Endpoint for S3	HTTPS	Lambda updates or overwrites document in S3 via API Gateway Endpoint.
AWS Lambda (Delete Function)	API Gateway Endpoint for DynamoDB	HTTPS	Lambda deletes document metadata from DynamoDB via API Gateway Endpoint.
AWS Lambda (Delete Function)	API Gateway Endpoint for S3	HTTPS	Lambda deletes document from S3 via API Gateway Endpoint.
On-Premises API-C	API Gateway Endpoint for DynamoDB	HTTPS	API-C directly interacts with DynamoDB via API Gateway Endpoint for querying metadata (if required).











import json
import boto3
import uuid
import os

dynamodb = boto3.client('dynamodb')
s3 = boto3.client('s3')
TABLE_NAME = os.environ['TABLE_NAME']
BUCKET_NAME = os.environ['BUCKET_NAME']

def generate_guid():
    return str(uuid.uuid4())

def create_document(event, context):
    guid = generate_guid()
    document_key = f"documents/{guid}"
    s3.put_object(Bucket=BUCKET_NAME, Key=document_key, Body=event['document_content'])
    
    document_url = f"https://{BUCKET_NAME}.s3.amazonaws.com/{document_key}"
    metadata = {
        'GUID': {'S': guid},
        'Filename': {'S': event['filename']},
        'CreatedAt': {'S': event['created_at']},
        'DocumentURL': {'S': document_url}
    }
    dynamodb.put_item(TableName=TABLE_NAME, Item=metadata)
    
    return {"statusCode": 200, "body": json.dumps({"GUID": guid, "DocumentURL": document_url})}

def read_document(event, context):
    guid = event['GUID']
    response = dynamodb.get_item(TableName=TABLE_NAME, Key={'GUID': {'S': guid}})
    if 'Item' not in response:
        return {"statusCode": 404, "body": "Document not found"}
    
    return {"statusCode": 200, "body": json.dumps(response['Item'])}

def update_document(event, context):
    guid = event['GUID']
    updated_metadata = event.get('metadata', {})
    
    update_expression = "SET " + ", ".join(f"{k} = :{k}" for k in updated_metadata.keys())
    expression_values = {f":{k}": {'S': v} for k, v in updated_metadata.items()}
    
    dynamodb.update_item(
        TableName=TABLE_NAME,
        Key={'GUID': {'S': guid}},
        UpdateExpression=update_expression,
        ExpressionAttributeValues=expression_values
    )
    
    return {"statusCode": 200, "body": "Document metadata updated"}

def delete_document(event, context):
    guid = event['GUID']
    response = dynamodb.get_item(TableName=TABLE_NAME, Key={'GUID': {'S': guid}})
    if 'Item' not in response:
        return {"statusCode": 404, "body": "Document not found"}
    
    document_url = response['Item']['DocumentURL']['S']
    document_key = document_url.split(f"https://{BUCKET_NAME}.s3.amazonaws.com/")[-1]
    s3.delete_object(Bucket=BUCKET_NAME, Key=document_key)
    dynamodb.delete_item(TableName=TABLE_NAME, Key={'GUID': {'S': guid}})
    
    return {"statusCode": 200, "body": "Document deleted"}




CloudFormation template to include:

S3 Bucket for document storage.
DynamoDB Table for metadata storage (with on-demand billing mode).
API Gateway for handling requests.
Separate Lambda Functions for Create, Read, Update, and Delete operations.
IAM Roles with the necessary permissions for Lambda, S3, and DynamoDB.
VPC Gateway Endpoints for S3 and DynamoDB (configured for EU-WEST region).





🛠 Step-by-Step Document Upload Flow
1️⃣ User sends a POST request with a document file to API-C.
2️⃣ API-C forwards the request to API Gateway.
3️⃣ API Gateway routes the request to CreateDocumentLambda.
4️⃣ Lambda generates a unique GUID for tracking the document.
5️⃣ Lambda uploads the document to S3, using GUID as the filename (s3://bucket-name/GUID.pdf).
6️⃣ Lambda stores metadata in DynamoDB, including:

GUID
S3 object path
Upload timestamp
7️⃣ Lambda returns GUID in the response.
8️⃣ API Gateway sends the response to API-C.
9️⃣ API-C delivers the response to the on-premises application.
📌 Process Flow Diagram (PlantUML Code)
Use this PlantUML code to generate the exact upload flow:

plantuml
Copy
Edit
@startuml
title Document Upload Process Flow

actor User
participant "On-Premises App" as App
participant "API-C" as API_C
participant "API Gateway" as APIGW
participant "CreateDocumentLambda" as Lambda
participant "Amazon S3" as S3
participant "Amazon DynamoDB" as DynamoDB

User -> App: Send POST request (Document)
App -> API_C: Forward request
API_C -> APIGW: Forward to API Gateway
APIGW -> Lambda: Invoke CreateDocumentLambda

Lambda -> Lambda: Generate GUID
Lambda -> S3: Upload document (GUID-based filename)
Lambda -> DynamoDB: Store metadata (GUID, S3 path, timestamp)

Lambda -> APIGW: Return GUID
APIGW -> API_C: Forward GUID response
API_C -> App: Deliver GUID
App -> User: Show GUID for future reference

@enduml




--------------------------
@startuml
title Document Update Process Flow

actor User
participant "On-Premises App" as App
participant "API-C" as API_C
participant "API Gateway" as APIGW
participant "UpdateDocumentLambda" as Lambda
participant "Amazon S3" as S3
participant "Amazon DynamoDB" as DynamoDB

User -> App: Send PUT request (GUID, Updated Document)
App -> API_C: Forward request
API_C -> APIGW: Forward to API Gateway
APIGW -> Lambda: Invoke UpdateDocumentLambda

Lambda -> DynamoDB: Check if GUID exists
alt Document Found
    Lambda -> S3: Overwrite existing document
    Lambda -> DynamoDB: Update metadata (timestamp, version)
    Lambda -> APIGW: Return success (200 OK)
else Document Not Found
    Lambda -> APIGW: Return error (404 Not Found)
end

APIGW -> API_C: Forward response
API_C -> App: Deliver response
App -> User: Show success/error message

@enduml




1️⃣ User sends a PUT request with GUID and updated document to API-C.
2️⃣ API-C forwards the request to API Gateway.
3️⃣ API Gateway triggers UpdateDocumentLambda.
4️⃣ Lambda checks in DynamoDB if the document exists.

✅ If exists: Proceed to update.
❌ If not found: Return an error message.
5️⃣ Lambda updates the document in S3 (overwrites existing file).
6️⃣ Lambda updates metadata (modification timestamp, version, etc.) in DynamoDB.
7️⃣ Lambda returns a success response to API Gateway.
8️⃣ API Gateway forwards response to API-C and then to the client.


User sends PUT request → API-C → API Gateway
API Gateway invokes Lambda
Lambda checks DynamoDB (Yes: Update S3 & metadata, No: Return error)
Lambda sends response to API Gateway → API-C → On-Premises App → User






Process Flow
1️⃣ User sends a GET request with GUID to API-C.
2️⃣ API-C forwards the request to API Gateway.
3️⃣ API Gateway triggers the Read Lambda function.
4️⃣ Lambda fetches metadata from DynamoDB to locate the document in S3.
5️⃣ Lambda retrieves the document from S3.
6️⃣ Lambda sends the document back to the client via API Gateway.
7️⃣ API Gateway returns the document to API-C, which sends it to the user.


Flow of the Diagram
1️⃣ User sends a GET request (GUID) → (Process Shape)
2️⃣ API-C forwards request to API Gateway → (Process Shape)
3️⃣ API Gateway triggers Read Lambda → (Process Shape)
4️⃣ Lambda queries DynamoDB for metadata → (Process Shape)
5️⃣ Decision: Document exists in DynamoDB? (Diamond Shape)

Yes → Retrieve document from S3 → Lambda returns document to API Gateway → API Gateway forwards document to API-C → API-C delivers document to User.
No → Return "Document Not Found" error → API Gateway forwards error to API-C → API-C shows error message to User.
6️⃣ End (Oval Shape)




-------------------------------
Explanation of the Flow
✅ User Initiates Delete Request: The on-premises application sends a request via API-C.
✅ API Gateway Routes Request: The request is routed to Lambda.
✅ Lambda Checks Metadata: It verifies if the document exists in DynamoDB.
✅ If Document Exists:

Fetch metadata from DynamoDB.
Delete the document from S3.
Remove the metadata entry from DynamoDB.
Send success response.
✅ If Document Does Not Exist:
Return a "Document Not Found" error.
✅ API Gateway & API-C Forward Response: The response is sent back to the user.








Step 2: Add Shapes for Process Flow
1️⃣ From the left panel, drag the following shapes onto the canvas:

Oval (Terminator) → For "Start" and "End".
Rectangle (Process) → For API calls and actions.
Diamond (Decision) → For checking document existence.
2️⃣ Arrange the shapes in the following order:

Start (Oval)
User Sends DELETE Request (Rectangle)
API-C Forwards Request (Rectangle)
API Gateway Routes Request (Rectangle)
Lambda Function Invoked (Rectangle)
Decision: Document Exists in DynamoDB? (Diamond)
If Yes → Fetch metadata → Delete from S3 → Remove metadata from DynamoDB → Send Success Response.
If No → Return "Document Not Found" Error.
API Gateway & API-C Send Response (Rectangle)
User Receives Response (Rectangle)
End (Oval)






Sequence Flow for Document Deletion
1️⃣ User (On-Premises App) requests to delete a document using the GUID.
2️⃣ API-C acts as an intermediary, forwarding the request securely to API Gateway.
3️⃣ API Gateway routes the request to the Lambda function.
4️⃣ Lambda function queries DynamoDB to verify document existence.
5️⃣ Lambda function deletes the document from S3.
6️⃣ Lambda function removes metadata from DynamoDB.
7️⃣ Lambda function returns a success response to the calling application.



Sequence Flow for Document Update
1️⃣ User (On-Premises App) requests to update a document using the GUID.
2️⃣ API-C acts as an intermediary, forwarding the request securely to API Gateway.
3️⃣ API Gateway forwards the request to the Lambda function.
4️⃣ Lambda function queries DynamoDB to verify document existence.
5️⃣ Lambda function uploads the updated document to S3, replacing the old version.
6️⃣ Lambda updates metadata in DynamoDB (e.g., modified timestamp, version).
7️⃣ Lambda function returns a success response to the calling application.




1️⃣ User (On-Premises App) requests a document using the GUID.
2️⃣ API Gateway forwards the request to Lambda.
3️⃣ Lambda queries DynamoDB for the S3 path of the document.
4️⃣ Lambda fetches the document from S3.
5️⃣ Lambda returns the actual document content to the calling application.
6️⃣ Application receives the document and processes it.

Document Upload Flow
User uploads a document from the on-premises application.
The request is routed via AWS Direct Connect to API Gateway.
API Gateway triggers a Lambda function to process the upload.
Lambda performs the following actions:
Generates a unique GUID for tracking.
Uploads the document to an S3 bucket (s3://document-bucket/GUID.pdf).
Stores metadata (GUID, filename, upload time, S3 path) in DynamoDB.
Lambda returns the GUID to the client for future reference.
4. API Endpoint
Method	Endpoint	Description
POST	/upload	Uploads a document, stores metadata, and returns a GUID.
Request Example
json
Copy
Edit
{
  "filename": "contract.pdf",
  "content": "<base64-encoded-file>"
}
Response Example
json
Copy
Edit
{
  "guid": "abc123-xyz789",
  "message": "Document uploaded successfully."
}
5. Security Measures
✅ IAM Policies restrict API and S3 access.
✅ S3 Encryption ensures document security.
✅ Pre-signed URLs prevent unauthorized access.
✅ CloudWatch Logs monitor API activity.

Would you like me to add Lucidchart diagrams or additional Confluence formatting (tables, code blocks, macros)? 🚀






You said:
document upload flow diagram in chart format
ChatGPT said:
You can create a document upload flow diagram in chart format using Lucidchart or the Confluence draw.io integration. Here's how the flow should look:

Document Upload Flow (Chart Format)
Flow Steps:
1️⃣ On-Premises Application → Sends document via AWS Direct Connect
2️⃣ API Gateway → Receives request & forwards to Lambda
3️⃣ Lambda Function → Generates GUID & uploads to S3
4️⃣ S3 Bucket → Stores the document securely
5️⃣ DynamoDB → Stores metadata (GUID, filename, timestamp, S3 path)
6️⃣ Lambda Response → Returns GUID to client

Diagram Representation (Flowchart Format)
scss
Copy
Edit
[On-Premises App] → (AWS Direct Connect) → [API Gateway] → [Lambda Function]  
→ [Amazon S3] (Stores File)  
→ [DynamoDB] (Stores Metadata)  
→ [Lambda Response] → [Returns





------------------------
Objective
The goal of this solution is to implement a highly scalable, secure, and efficient document management system that supports Create, Read, Update, and Delete (CRUD) operations. The system will leverage AWS cloud services, ensuring reliability, security, and performance while integrating with existing infrastructure via AWS Direct Connect.

Architecture Overview
The solution consists of the following AWS components:

API Gateway: Acts as an entry point, handling API requests from external services.
AWS Lambda: Manages separate functions for each CRUD operation.
Amazon S3: Stores documents securely with access control.
Amazon DynamoDB: Maintains metadata such as document GUID, S3 URL, timestamps, and other attributes.
AWS Direct Connect: Provides a dedicated, low-latency connection between on-premise infrastructure and AWS services.
Key Functionalities
Create Document:

Client uploads a document via API Gateway.
Lambda generates a GUID, stores metadata in DynamoDB, and uploads the document to S3.
GUID is returned to the client for future reference.
Read Document:

Client requests a document using its GUID.
Lambda retrieves metadata from DynamoDB and generates a signed URL from S3.
The signed URL is sent to the client for secure access.
Update Document:

Client sends a request with GUID and a new document.
Lambda updates the document in S3 and updates metadata in DynamoDB.
Delete Document:

Client sends a delete request with GUID.
Lambda removes the document from S3 and metadata from DynamoDB.
Benefits of the Solution
✅ Scalability: Serverless architecture scales automatically.
✅ Security: AWS IAM policies, encryption, and signed URLs ensure data protection.
✅ Performance: Low-latency access via AWS Direct Connect.
✅ Cost-Effective: Pay-as-you-go model with serverless functions reducing infrastructure costs.
✅ Reliability: Highly available AWS services ensure system uptime.

Next Steps
Develop API contracts and security policies.
Deploy infrastructure using Infrastructure as Code (IaC) like Terraform or AWS CloudFormation.
Implement and test Lambda functions.
Optimize performance and monitoring with AWS CloudWatch and AWS X-Ray.



------------------------------------------------------------------------------
{
  "type": "document",
  "version": "1.0",
  "objects": [
    {
      "type": "shape",
      "id": "client",
      "x": 100,
      "y": 100,
      "width": 120,
      "height": 60,
      "text": "Client (Calling Service)"
    },
    {
      "type": "shape",
      "id": "direct_connect",
      "x": 250,
      "y": 100,
      "width": 140,
      "height": 60,
      "text": "AWS Direct Connect"
    },
    {
      "type": "shape",
      "id": "api_gateway",
      "x": 400,
      "y": 100,
      "width": 120,
      "height": 60,
      "text": "API Gateway"
    },
    {
      "type": "shape",
      "id": "lambda_create",
      "x": 550,
      "y": 50,
      "width": 140,
      "height": 60,
      "text": "Lambda (Create)"
    },
    {
      "type": "shape",
      "id": "lambda_read",
      "x": 550,
      "y": 120,
      "width": 140,
      "height": 60,
      "text": "Lambda (Read)"
    },
    {
      "type": "shape",
      "id": "lambda_update",
      "x": 550,
      "y": 190,
      "width": 140,
      "height": 60,
      "text": "Lambda (Update)"
    },
    {
      "type": "shape",
      "id": "lambda_delete",
      "x": 550,
      "y": 260,
      "width": 140,
      "height": 60,
      "text": "Lambda (Delete)"
    },
    {
      "type": "shape",
      "id": "s3",
      "x": 750,
      "y": 100,
      "width": 120,
      "height": 60,
      "text": "S3 (Document Storage)"
    },
    {
      "type": "shape",
      "id": "dynamodb",
      "x": 750,
      "y": 200,
      "width": 140,
      "height": 60,
      "text": "DynamoDB (Metadata Storage)"
    },
    {
      "type": "line",
      "from": "client",
      "to": "direct_connect",
      "text": "Secure Connection"
    },
    {
      "type": "line",
      "from": "direct_connect",
      "to": "api_gateway",
      "text": "API Requests"
    },
    {
      "type": "line",
      "from": "api_gateway",
      "to": "lambda_create",
      "text": "POST /documents"
    },
    {
      "type": "line",
      "from": "api_gateway",
      "to": "lambda_read",
      "text": "GET /documents/{id}"
    },
    {
      "type": "line",
      "from": "api_gateway",
      "to": "lambda_update",
      "text": "PUT /documents/{id}"
    },
    {
      "type": "line",
      "from": "api_gateway",
      "to": "lambda_delete",
      "text": "DELETE /documents/{id}"
    },
    {
      "type": "line",
      "from": "lambda_create",
      "to": "s3",
      "text": "Upload Document"
    },
    {
      "type": "line",
      "from": "lambda_create",
      "to": "dynamodb",
      "text": "Store Metadata (GUID, S3 URL)"
    },
    {
      "type": "line",
      "from": "lambda_read",
      "to": "dynamodb",
      "text": "Fetch Metadata"
    },
    {
      "type": "line",
      "from": "lambda_read",
      "to": "s3",
      "text": "Generate Signed URL"
    },
    {
      "type": "line",
      "from": "lambda_update",
      "to": "s3",
      "text": "Replace Document"
    },
    {
      "type": "line",
      "from": "lambda_update",
      "to": "dynamodb",
      "text": "Update Metadata"
    },
    {
      "type": "line",
      "from": "lambda_delete",
      "to": "s3",
      "text": "Delete Document"
    },
    {
      "type": "line",
      "from": "lambda_delete",
      "to": "dynamodb",
      "text": "Remove Metadata"
    }
  ]
}

------------
Flow:
Create Document (Upload)

Client → API Gateway → Lambda (Create) → S3 (Store File)
Lambda → DynamoDB (Store Metadata) → Response to Client
Read Document (Retrieve)

Client → API Gateway → Lambda (Read) → DynamoDB (Get Metadata)
Lambda → S3 (Generate Signed URL) → Response to Client
Update Document

Client → API Gateway → Lambda (Update) → S3 (Replace File)
Lambda → DynamoDB (Update Metadata) → Response to Client
Delete Document

Client → API Gateway → Lambda (Delete) → S3 (Delete File)
Lambda → DynamoDB (Remove Metadata) → Response to Client
