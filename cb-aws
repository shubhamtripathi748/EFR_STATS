Design Decisions & Rationale for Upload New Document Service
The document upload service is designed with security, scalability, reliability, and cost-efficiency in mind. Below are key design decisions and the rationale behind each.

1. Architecture Selection: Serverless (API Gateway + Lambda + S3 + DynamoDB)
✅ Design Decision: Use API Gateway, Lambda, S3, and DynamoDB instead of EC2-based services.
💡 Rationale:

Serverless autoscaling eliminates the need for infrastructure management.
Pay-per-use pricing optimizes cost (Lambda runs only when triggered).
Seamless integration with AWS native services (S3, DynamoDB).
High availability & fault tolerance with AWS-managed services.
2. Data Storage: S3 for Documents, DynamoDB for Metadata
✅ Design Decision: Store documents in S3 and metadata in DynamoDB rather than keeping both in a database.
💡 Rationale:

S3 optimized for large object storage with built-in durability (99.999999999% reliability).
DynamoDB provides fast metadata access with scalable, low-latency lookups.
Separation of concerns: Keeping metadata in a DB prevents expensive queries on S3.
3. Security: IAM Policies & Encryption
✅ Design Decision: Use IAM role-based access control and S3 Server-Side Encryption (SSE-KMS).
💡 Rationale:

Least privilege access ensures only specific Lambda functions can access S3 & DynamoDB.
Encryption at rest protects document data from unauthorized access.
VPC Gateway Endpoints for S3/DynamoDB ensure private communication (no exposure to the public internet).
4. API Gateway & Lambda for Stateless Processing
✅ Design Decision: API Gateway invokes separate Lambda functions for each operation (Upload, Read, Update, Delete).
💡 Rationale:

Stateless Lambda functions improve modularity and fault isolation.
Decoupling of business logic allows independent scaling of functions.
Automatic retries for transient failures (network errors, S3 upload issues).
5. Unique Identifier (GUID) for Document Tracking
✅ Design Decision: Generate a GUID instead of using filenames or database auto-increment IDs.
💡 Rationale:

Ensures uniqueness even across multiple AWS regions.
Prevents conflicts in concurrent document uploads.
Eases tracking & indexing in DynamoDB.
6. Failure Handling & Retries
✅ Design Decision: Implement retry logic and store migration status in Oracle for tracking.
💡 Rationale:

Retries reduce transient failures (e.g., temporary S3/DynamoDB issues).
Migration tracking in Oracle allows auditability of failed records.
Dead-letter queue (DLQ) for failed requests enables manual reprocessing if needed.
7. Performance Optimization: Multipart Upload for Large Files
✅ Design Decision: Use S3 Multipart Upload API for files >5MB.
💡 Rationale:

Faster uploads by breaking files into chunks and uploading in parallel.
Resumability ensures failure recovery for large files.
Reduces API Gateway & Lambda timeout risks for large document uploads.
8. Cost Optimization: On-Demand Services
✅ Design Decision: Use on-demand billing for DynamoDB and Lambda instead of provisioned capacity.
💡 Rationale:

Minimizes AWS costs by scaling resources based on actual traffic.
Avoids over-provisioning during low usage periods.
DynamoDB auto-scaling handles dynamic workloads efficiently.
Conclusion
The chosen design prioritizes security, scalability, reliability, and cost-efficiency while ensuring seamless integration with both on-premises systems and AWS services.





The Upload New Document service enables an application to securely store documents in AWS S3 and maintain metadata in DynamoDB. It follows a serverless architecture, using API Gateway, AWS Lambda, S3, and DynamoDB to ensure scalability, security, and reliability.


Service Flow & Steps
Step No.	Component	Action	Description
1	Application (On-Premises or Cloud)	Initiate Upload Request	Sends a document and metadata to API-C (On-Premises API Gateway) over HTTPS.
2	API-C (On-Premises)	Forward Request to AWS	Forwards the document and metadata to AWS API Gateway over HTTPS.
3	AWS API Gateway	Invoke Upload Lambda	Validates request and triggers AWS Lambda (CreateDocument Function).
4	AWS Lambda (CreateDocument Function)	Generate GUID	Generates a GUID (Unique Identifier) for tracking.
5	AWS Lambda → API Gateway Endpoint (S3)	Upload Document to S3	Calls S3 API to store the document and receives the S3 URL.
6	S3	Store Document	The document is saved in an S3 bucket with encryption enabled.
7	AWS Lambda → API Gateway Endpoint (DynamoDB)	Store Metadata in DynamoDB	Saves the document metadata (GUID, S3 URL, timestamps, etc.) in DynamoDB.
8	AWS API Gateway	Return Response	Returns GUID & success status to API-C (On-Premises).
9	API-C (On-Premises)	Confirm Upload	Updates the migration status in Oracle (if applicable) and notifies the application.
Service Features & Considerations
🔹 Security:
✅ HTTPS for secure data transfer.
✅ IAM roles & policies to restrict access to S3 and DynamoDB.
✅ Server-Side Encryption (S3 SSE-KMS or SSE-S3) for document security.

🔹 Scalability & Performance:
✅ Multipart Uploads for large file handling.
✅ On-Demand Lambda & DynamoDB Billing to handle variable workloads.
✅ VPC Gateway Endpoints for S3 & DynamoDB to avoid public internet exposure.

🔹 Reliability & Failure Handling:
✅ Retry Mechanism (for S3 upload, DynamoDB write failures).
✅ API Rate Limiting & Throttling (to prevent overload).
✅ Logging & Monitoring via CloudWatch & X-Ray.

Final Output
📌 Success Response:

GUID (Unique Identifier)
S3 URL (for document retrieval)
HTTP 200 (Success)
📌 Failure Handling:

Retry on transient failures (S3, DynamoDB errors)
Fallback to logging & manual reprocessing for failed documents













Invalid API Request	API-C sends malformed or unauthorized request to API Gateway	API-C → API Gateway	400 (Bad Request) / 403 (Forbidden)
Authentication Failure	API request missing or incorrect IAM credentials	API-C → API Gateway	401 (Unauthorized)
Rate Limit Exceeded	API Gateway rate limits exceeded due to high migration load	API-C → API Gateway	429 (Too Many Requests)
Lambda Invocation Failure	AWS Lambda execution error due to internal issue	API Gateway → Lambda	500 (Internal Server Error)
S3 Upload Failure	Document failed to upload to S3 (e.g., timeout, permission issue)	Lambda → API Gateway Endpoint (S3) → S3	500 (Internal Server Error)
S3 Multipart Upload Failure	Large document upload fails mid-transfer	Lambda → S3	500 (Internal Server Error)
DynamoDB Write Failure	Metadata storage failure due to capacity limits or table issues	Lambda → API Gateway Endpoint (DynamoDB) → DynamoDB	500 (Internal Server Error)
Network Timeout	API Gateway request to Lambda/S3/DynamoDB takes too long and times out	API Gateway → Lambda/S3/DynamoDB	504 (Gateway Timeout)
Database Connection Failure	Oracle DB not reachable from API-C or migration job	API-C → Oracle	500 (Internal Server Error)
GUID Generation Error	GUID creation fails due to unexpected Lambda execution issue	Lambda	500 (Internal Server Error)
Validation Failure	Validation step fails (S3 document not found, metadata mismatch)	On-Prem Validation Job → API Gateway → DynamoDB	404 (Not Found)
Retry Exhausted	Multiple retries failed, marking migration as permanently failed	Retry Handler	No HTTP Code (Logged for tracking)
VPC Endpoint Connectivity Failure	API Gateway Endpoint cannot reach S3 or DynamoDB due to misconfiguration	API Gateway Endpoint → S3/DynamoDB	503 (Service Unavailable)
Circuit Breaker Triggered	API-C prevents excessive retries due to continuous failures	API-C	No HTTP Code (Logged and flagged)
Key Takeaways
Client-Side Errors (4xx): Authentication, authorization, rate limits, invalid requests
Server-Side Errors (5xx): Failures in AWS services, Lambda execution, S3/DynamoDB issues
Retries & Timeouts: Built-in retry logic for transient failures (S3/DynamoDB updates)









Sequential Order of Processing: Document Migration from On-Premises to AWS
The migration follows a step-by-step sequence ensuring secure transfer, metadata storage, and validation. Below is the exact order of processing:

1. Extraction from On-Premises
✅ Step 1: Spring Scheduler Job (On-Premises) triggers the migration process at scheduled intervals.
✅ Step 2: The scheduler extracts document data and metadata from the on-prem file system or database.
✅ Step 3: The extracted document and metadata are sent to API-C (On-Premises API Gateway) over HTTPS.

2. Secure Transfer to AWS
✅ Step 4: API-C forwards the request to AWS API Gateway (exposed via HTTPS).
✅ Step 5: AWS API Gateway validates the request and forwards it to the appropriate AWS Lambda function.
✅ Step 6: Lambda (CreateDocument function) processes the request and generates a GUID (Unique Identifier) for tracking.

3. Uploading Document to AWS S3
✅ Step 7: Lambda calls the API Gateway Endpoint for S3, which ensures a secure transfer.
✅ Step 8: The document is uploaded to S3 and a pre-signed S3 URL is generated.

4. Storing Metadata in DynamoDB
✅ Step 9: Lambda calls the API Gateway Endpoint for DynamoDB.
✅ Step 10: The document metadata (GUID, S3 URL, timestamps) is stored in DynamoDB.

5. Acknowledgment & Status Update
✅ Step 11: Lambda sends a response back to API Gateway, containing the GUID and success status.
✅ Step 12: API Gateway forwards the response to API-C (On-Premises Gateway).
✅ Step 13: API-C updates the migration status in the on-prem database (Oracle, if applicable).

6. Post-Migration Validation
✅ Step 14: On-premises system verifies if the migrated document exists in S3 by checking DynamoDB records.
✅ Step 15: If validation is successful, the migration status in Oracle is updated to SUCCESS.
✅ Step 16: If validation fails, a retry mechanism is triggered or an alert is raised for manual intervention.

7. Error Handling & Retry Mechanism
🔄 Step 17: If any failure occurs in S3 upload or DynamoDB update:

Retry up to 3 times with exponential backoff.
If all retries fail, the failure is logged for manual resolution.
Migration status in Oracle is marked as FAILED, and the document is queued for reattempt.
Final Process Flow Summary
mathematica
Copy
Edit
1️⃣ Extract document → 2️⃣ API-C (On-Prem) → 3️⃣ AWS API Gateway → 4️⃣ AWS Lambda  
5️⃣ Upload to S3 → 6️⃣ Store Metadata in DynamoDB → 7️⃣ Return GUID & Status  
8️⃣ Update On-Prem Migration Table → 9️⃣ Validate Document in S3 →  🔟 Mark Success/Failure






















This service facilitates the migration of documents from an on-premises environment to AWS, leveraging API Gateway, AWS Lambda, S3, and DynamoDB. It ensures a secure, scalable, and automated process for transferring and managing documents in AWS.



Service Components & Flow
1. Source (On-Premises)
Application & API-C: The on-premises system initiates the migration.
Spring Scheduler Job: Automates the migration process by triggering API calls at scheduled intervals.
Existing Document Storage: Documents reside in on-prem file servers or databases before migration.
2. Migration Process
Step 1: Document Extraction

Spring Scheduler extracts document data and metadata from the source system.
Calls API-C (On-Premises Gateway) to initiate the migration request.
Step 2: Secure Transfer via API Gateway

API-C forwards the request to AWS API Gateway over HTTPS.
API Gateway invokes the AWS Lambda "CreateDocument" function for processing.
Step 3: Upload to S3

Lambda generates a GUID for document tracking.
Document is uploaded to S3 via API Gateway Endpoint.
The S3 URL is generated for retrieval.
Step 4: Metadata Storage in DynamoDB

Lambda stores document metadata (GUID, S3 URL, timestamps) in DynamoDB using API Gateway Endpoint.
Step 5: Acknowledgment & Status Update

Success Response: GUID is returned to API-C and the on-prem system updates the migration status.
Failure Handling: If migration fails, retries occur. If all retries fail, the failure is logged in Oracle (if tracking is enabled).
3. AWS Services Used
AWS Service	Role in Migration
API Gateway	Securely exposes endpoints for document migration.
AWS Lambda	Processes requests, handles GUID generation, and interacts with S3 & DynamoDB.
S3	Stores migrated documents securely.
DynamoDB	Stores document metadata (GUID, S3 URL, timestamps).
API Gateway Endpoint	Ensures private, fast access to S3 and DynamoDB without traversing the internet.
4. Error Handling & Retry Strategy
DynamoDB Update Failure → Retry up to 3 times (exponential backoff).
S3 Upload Failure → Retry via API Gateway, log errors in CloudWatch.
API-C/AWS Communication Issues → Implement circuit breaker pattern & fallback mechanism.
5. Security Considerations
IAM Policies → Enforce least privilege access for Lambda & API Gateway.
Data Encryption → Documents stored in S3 are encrypted (SSE-S3/KMS).
VPC Endpoints → API Gateway Endpoints used for private S3/DynamoDB access.
6. Post-Migration Validation
Scheduled job compares Oracle Migration Status Table (on-prem) with DynamoDB entries to ensure data consistency.
API for validating document availability in S3 before marking migration as complete.




To handle failed status in the database update flow, we need to introduce a retry mechanism. This ensures that if updating the metadata in DynamoDB fails, the system will retry a few times before marking the operation as failed.

Key Additions:
✔ Retry Logic: Introduced up to 3 retries in case metadata update fails.
✔ Failure Handling: If retries fail, the system logs the failure and stores a FAILED status.
✔ Seamless Recovery: If retry succeeds, the operation completes as us



An Interface Matrix is used to document the communication between different components in your architecture. Since you're using API Gateway, Lambda, and DynamoDB for CRUD operations and have on-premises components like Migration Service and API-C, here’s how you can structure your Interface Matrix:
Now, all S3 and DynamoDB interactions happen through API Gateway Endpoints, ensuring secure and controlled access. 




On-Premises Migration Service	API-C	HTTPS	Migration service calls API-C for data processing before integration.
API-C	AWS API Gateway	HTTPS	API-C sends document CRUD requests to API Gateway.
AWS API Gateway	AWS Lambda (CRUD functions)	HTTPS	API Gateway triggers the appropriate Lambda function for CRUD operations.
AWS Lambda (Create Function)	API Gateway Endpoint for S3	HTTPS	Lambda uploads the document to S3 via API Gateway Endpoint.
AWS Lambda (Create Function)	API Gateway Endpoint for DynamoDB	HTTPS	Lambda stores document metadata (GUID, S3 URL) in DynamoDB via API Gateway Endpoint.
AWS Lambda (Read Function)	API Gateway Endpoint for DynamoDB	HTTPS	Lambda retrieves metadata for requested documents via API Gateway Endpoint.
AWS Lambda (Read Function)	API Gateway Endpoint for S3	HTTPS	Lambda fetches document from S3 via API Gateway Endpoint.
AWS Lambda (Update Function)	API Gateway Endpoint for DynamoDB	HTTPS	Lambda updates document metadata in DynamoDB via API Gateway Endpoint.
AWS Lambda (Update Function)	API Gateway Endpoint for S3	HTTPS	Lambda updates or overwrites document in S3 via API Gateway Endpoint.
AWS Lambda (Delete Function)	API Gateway Endpoint for DynamoDB	HTTPS	Lambda deletes document metadata from DynamoDB via API Gateway Endpoint.
AWS Lambda (Delete Function)	API Gateway Endpoint for S3	HTTPS	Lambda deletes document from S3 via API Gateway Endpoint.
On-Premises API-C	API Gateway Endpoint for DynamoDB	HTTPS	API-C directly interacts with DynamoDB via API Gateway Endpoint for querying metadata (if required).











import json
import boto3
import uuid
import os

dynamodb = boto3.client('dynamodb')
s3 = boto3.client('s3')
TABLE_NAME = os.environ['TABLE_NAME']
BUCKET_NAME = os.environ['BUCKET_NAME']

def generate_guid():
    return str(uuid.uuid4())

def create_document(event, context):
    guid = generate_guid()
    document_key = f"documents/{guid}"
    s3.put_object(Bucket=BUCKET_NAME, Key=document_key, Body=event['document_content'])
    
    document_url = f"https://{BUCKET_NAME}.s3.amazonaws.com/{document_key}"
    metadata = {
        'GUID': {'S': guid},
        'Filename': {'S': event['filename']},
        'CreatedAt': {'S': event['created_at']},
        'DocumentURL': {'S': document_url}
    }
    dynamodb.put_item(TableName=TABLE_NAME, Item=metadata)
    
    return {"statusCode": 200, "body": json.dumps({"GUID": guid, "DocumentURL": document_url})}

def read_document(event, context):
    guid = event['GUID']
    response = dynamodb.get_item(TableName=TABLE_NAME, Key={'GUID': {'S': guid}})
    if 'Item' not in response:
        return {"statusCode": 404, "body": "Document not found"}
    
    return {"statusCode": 200, "body": json.dumps(response['Item'])}

def update_document(event, context):
    guid = event['GUID']
    updated_metadata = event.get('metadata', {})
    
    update_expression = "SET " + ", ".join(f"{k} = :{k}" for k in updated_metadata.keys())
    expression_values = {f":{k}": {'S': v} for k, v in updated_metadata.items()}
    
    dynamodb.update_item(
        TableName=TABLE_NAME,
        Key={'GUID': {'S': guid}},
        UpdateExpression=update_expression,
        ExpressionAttributeValues=expression_values
    )
    
    return {"statusCode": 200, "body": "Document metadata updated"}

def delete_document(event, context):
    guid = event['GUID']
    response = dynamodb.get_item(TableName=TABLE_NAME, Key={'GUID': {'S': guid}})
    if 'Item' not in response:
        return {"statusCode": 404, "body": "Document not found"}
    
    document_url = response['Item']['DocumentURL']['S']
    document_key = document_url.split(f"https://{BUCKET_NAME}.s3.amazonaws.com/")[-1]
    s3.delete_object(Bucket=BUCKET_NAME, Key=document_key)
    dynamodb.delete_item(TableName=TABLE_NAME, Key={'GUID': {'S': guid}})
    
    return {"statusCode": 200, "body": "Document deleted"}




CloudFormation template to include:

S3 Bucket for document storage.
DynamoDB Table for metadata storage (with on-demand billing mode).
API Gateway for handling requests.
Separate Lambda Functions for Create, Read, Update, and Delete operations.
IAM Roles with the necessary permissions for Lambda, S3, and DynamoDB.
VPC Gateway Endpoints for S3 and DynamoDB (configured for EU-WEST region).





🛠 Step-by-Step Document Upload Flow
1️⃣ User sends a POST request with a document file to API-C.
2️⃣ API-C forwards the request to API Gateway.
3️⃣ API Gateway routes the request to CreateDocumentLambda.
4️⃣ Lambda generates a unique GUID for tracking the document.
5️⃣ Lambda uploads the document to S3, using GUID as the filename (s3://bucket-name/GUID.pdf).
6️⃣ Lambda stores metadata in DynamoDB, including:

GUID
S3 object path
Upload timestamp
7️⃣ Lambda returns GUID in the response.
8️⃣ API Gateway sends the response to API-C.
9️⃣ API-C delivers the response to the on-premises application.
📌 Process Flow Diagram (PlantUML Code)
Use this PlantUML code to generate the exact upload flow:

plantuml
Copy
Edit
@startuml
title Document Upload Process Flow

actor User
participant "On-Premises App" as App
participant "API-C" as API_C
participant "API Gateway" as APIGW
participant "CreateDocumentLambda" as Lambda
participant "Amazon S3" as S3
participant "Amazon DynamoDB" as DynamoDB

User -> App: Send POST request (Document)
App -> API_C: Forward request
API_C -> APIGW: Forward to API Gateway
APIGW -> Lambda: Invoke CreateDocumentLambda

Lambda -> Lambda: Generate GUID
Lambda -> S3: Upload document (GUID-based filename)
Lambda -> DynamoDB: Store metadata (GUID, S3 path, timestamp)

Lambda -> APIGW: Return GUID
APIGW -> API_C: Forward GUID response
API_C -> App: Deliver GUID
App -> User: Show GUID for future reference

@enduml




--------------------------
@startuml
title Document Update Process Flow

actor User
participant "On-Premises App" as App
participant "API-C" as API_C
participant "API Gateway" as APIGW
participant "UpdateDocumentLambda" as Lambda
participant "Amazon S3" as S3
participant "Amazon DynamoDB" as DynamoDB

User -> App: Send PUT request (GUID, Updated Document)
App -> API_C: Forward request
API_C -> APIGW: Forward to API Gateway
APIGW -> Lambda: Invoke UpdateDocumentLambda

Lambda -> DynamoDB: Check if GUID exists
alt Document Found
    Lambda -> S3: Overwrite existing document
    Lambda -> DynamoDB: Update metadata (timestamp, version)
    Lambda -> APIGW: Return success (200 OK)
else Document Not Found
    Lambda -> APIGW: Return error (404 Not Found)
end

APIGW -> API_C: Forward response
API_C -> App: Deliver response
App -> User: Show success/error message

@enduml




1️⃣ User sends a PUT request with GUID and updated document to API-C.
2️⃣ API-C forwards the request to API Gateway.
3️⃣ API Gateway triggers UpdateDocumentLambda.
4️⃣ Lambda checks in DynamoDB if the document exists.

✅ If exists: Proceed to update.
❌ If not found: Return an error message.
5️⃣ Lambda updates the document in S3 (overwrites existing file).
6️⃣ Lambda updates metadata (modification timestamp, version, etc.) in DynamoDB.
7️⃣ Lambda returns a success response to API Gateway.
8️⃣ API Gateway forwards response to API-C and then to the client.


User sends PUT request → API-C → API Gateway
API Gateway invokes Lambda
Lambda checks DynamoDB (Yes: Update S3 & metadata, No: Return error)
Lambda sends response to API Gateway → API-C → On-Premises App → User






Process Flow
1️⃣ User sends a GET request with GUID to API-C.
2️⃣ API-C forwards the request to API Gateway.
3️⃣ API Gateway triggers the Read Lambda function.
4️⃣ Lambda fetches metadata from DynamoDB to locate the document in S3.
5️⃣ Lambda retrieves the document from S3.
6️⃣ Lambda sends the document back to the client via API Gateway.
7️⃣ API Gateway returns the document to API-C, which sends it to the user.


Flow of the Diagram
1️⃣ User sends a GET request (GUID) → (Process Shape)
2️⃣ API-C forwards request to API Gateway → (Process Shape)
3️⃣ API Gateway triggers Read Lambda → (Process Shape)
4️⃣ Lambda queries DynamoDB for metadata → (Process Shape)
5️⃣ Decision: Document exists in DynamoDB? (Diamond Shape)

Yes → Retrieve document from S3 → Lambda returns document to API Gateway → API Gateway forwards document to API-C → API-C delivers document to User.
No → Return "Document Not Found" error → API Gateway forwards error to API-C → API-C shows error message to User.
6️⃣ End (Oval Shape)




-------------------------------
Explanation of the Flow
✅ User Initiates Delete Request: The on-premises application sends a request via API-C.
✅ API Gateway Routes Request: The request is routed to Lambda.
✅ Lambda Checks Metadata: It verifies if the document exists in DynamoDB.
✅ If Document Exists:

Fetch metadata from DynamoDB.
Delete the document from S3.
Remove the metadata entry from DynamoDB.
Send success response.
✅ If Document Does Not Exist:
Return a "Document Not Found" error.
✅ API Gateway & API-C Forward Response: The response is sent back to the user.








Step 2: Add Shapes for Process Flow
1️⃣ From the left panel, drag the following shapes onto the canvas:

Oval (Terminator) → For "Start" and "End".
Rectangle (Process) → For API calls and actions.
Diamond (Decision) → For checking document existence.
2️⃣ Arrange the shapes in the following order:

Start (Oval)
User Sends DELETE Request (Rectangle)
API-C Forwards Request (Rectangle)
API Gateway Routes Request (Rectangle)
Lambda Function Invoked (Rectangle)
Decision: Document Exists in DynamoDB? (Diamond)
If Yes → Fetch metadata → Delete from S3 → Remove metadata from DynamoDB → Send Success Response.
If No → Return "Document Not Found" Error.
API Gateway & API-C Send Response (Rectangle)
User Receives Response (Rectangle)
End (Oval)






Sequence Flow for Document Deletion
1️⃣ User (On-Premises App) requests to delete a document using the GUID.
2️⃣ API-C acts as an intermediary, forwarding the request securely to API Gateway.
3️⃣ API Gateway routes the request to the Lambda function.
4️⃣ Lambda function queries DynamoDB to verify document existence.
5️⃣ Lambda function deletes the document from S3.
6️⃣ Lambda function removes metadata from DynamoDB.
7️⃣ Lambda function returns a success response to the calling application.



Sequence Flow for Document Update
1️⃣ User (On-Premises App) requests to update a document using the GUID.
2️⃣ API-C acts as an intermediary, forwarding the request securely to API Gateway.
3️⃣ API Gateway forwards the request to the Lambda function.
4️⃣ Lambda function queries DynamoDB to verify document existence.
5️⃣ Lambda function uploads the updated document to S3, replacing the old version.
6️⃣ Lambda updates metadata in DynamoDB (e.g., modified timestamp, version).
7️⃣ Lambda function returns a success response to the calling application.




1️⃣ User (On-Premises App) requests a document using the GUID.
2️⃣ API Gateway forwards the request to Lambda.
3️⃣ Lambda queries DynamoDB for the S3 path of the document.
4️⃣ Lambda fetches the document from S3.
5️⃣ Lambda returns the actual document content to the calling application.
6️⃣ Application receives the document and processes it.

Document Upload Flow
User uploads a document from the on-premises application.
The request is routed via AWS Direct Connect to API Gateway.
API Gateway triggers a Lambda function to process the upload.
Lambda performs the following actions:
Generates a unique GUID for tracking.
Uploads the document to an S3 bucket (s3://document-bucket/GUID.pdf).
Stores metadata (GUID, filename, upload time, S3 path) in DynamoDB.
Lambda returns the GUID to the client for future reference.
4. API Endpoint
Method	Endpoint	Description
POST	/upload	Uploads a document, stores metadata, and returns a GUID.
Request Example
json
Copy
Edit
{
  "filename": "contract.pdf",
  "content": "<base64-encoded-file>"
}
Response Example
json
Copy
Edit
{
  "guid": "abc123-xyz789",
  "message": "Document uploaded successfully."
}
5. Security Measures
✅ IAM Policies restrict API and S3 access.
✅ S3 Encryption ensures document security.
✅ Pre-signed URLs prevent unauthorized access.
✅ CloudWatch Logs monitor API activity.

Would you like me to add Lucidchart diagrams or additional Confluence formatting (tables, code blocks, macros)? 🚀






You said:
document upload flow diagram in chart format
ChatGPT said:
You can create a document upload flow diagram in chart format using Lucidchart or the Confluence draw.io integration. Here's how the flow should look:

Document Upload Flow (Chart Format)
Flow Steps:
1️⃣ On-Premises Application → Sends document via AWS Direct Connect
2️⃣ API Gateway → Receives request & forwards to Lambda
3️⃣ Lambda Function → Generates GUID & uploads to S3
4️⃣ S3 Bucket → Stores the document securely
5️⃣ DynamoDB → Stores metadata (GUID, filename, timestamp, S3 path)
6️⃣ Lambda Response → Returns GUID to client

Diagram Representation (Flowchart Format)
scss
Copy
Edit
[On-Premises App] → (AWS Direct Connect) → [API Gateway] → [Lambda Function]  
→ [Amazon S3] (Stores File)  
→ [DynamoDB] (Stores Metadata)  
→ [Lambda Response] → [Returns





------------------------
Objective
The goal of this solution is to implement a highly scalable, secure, and efficient document management system that supports Create, Read, Update, and Delete (CRUD) operations. The system will leverage AWS cloud services, ensuring reliability, security, and performance while integrating with existing infrastructure via AWS Direct Connect.

Architecture Overview
The solution consists of the following AWS components:

API Gateway: Acts as an entry point, handling API requests from external services.
AWS Lambda: Manages separate functions for each CRUD operation.
Amazon S3: Stores documents securely with access control.
Amazon DynamoDB: Maintains metadata such as document GUID, S3 URL, timestamps, and other attributes.
AWS Direct Connect: Provides a dedicated, low-latency connection between on-premise infrastructure and AWS services.
Key Functionalities
Create Document:

Client uploads a document via API Gateway.
Lambda generates a GUID, stores metadata in DynamoDB, and uploads the document to S3.
GUID is returned to the client for future reference.
Read Document:

Client requests a document using its GUID.
Lambda retrieves metadata from DynamoDB and generates a signed URL from S3.
The signed URL is sent to the client for secure access.
Update Document:

Client sends a request with GUID and a new document.
Lambda updates the document in S3 and updates metadata in DynamoDB.
Delete Document:

Client sends a delete request with GUID.
Lambda removes the document from S3 and metadata from DynamoDB.
Benefits of the Solution
✅ Scalability: Serverless architecture scales automatically.
✅ Security: AWS IAM policies, encryption, and signed URLs ensure data protection.
✅ Performance: Low-latency access via AWS Direct Connect.
✅ Cost-Effective: Pay-as-you-go model with serverless functions reducing infrastructure costs.
✅ Reliability: Highly available AWS services ensure system uptime.

Next Steps
Develop API contracts and security policies.
Deploy infrastructure using Infrastructure as Code (IaC) like Terraform or AWS CloudFormation.
Implement and test Lambda functions.
Optimize performance and monitoring with AWS CloudWatch and AWS X-Ray.



------------------------------------------------------------------------------
{
  "type": "document",
  "version": "1.0",
  "objects": [
    {
      "type": "shape",
      "id": "client",
      "x": 100,
      "y": 100,
      "width": 120,
      "height": 60,
      "text": "Client (Calling Service)"
    },
    {
      "type": "shape",
      "id": "direct_connect",
      "x": 250,
      "y": 100,
      "width": 140,
      "height": 60,
      "text": "AWS Direct Connect"
    },
    {
      "type": "shape",
      "id": "api_gateway",
      "x": 400,
      "y": 100,
      "width": 120,
      "height": 60,
      "text": "API Gateway"
    },
    {
      "type": "shape",
      "id": "lambda_create",
      "x": 550,
      "y": 50,
      "width": 140,
      "height": 60,
      "text": "Lambda (Create)"
    },
    {
      "type": "shape",
      "id": "lambda_read",
      "x": 550,
      "y": 120,
      "width": 140,
      "height": 60,
      "text": "Lambda (Read)"
    },
    {
      "type": "shape",
      "id": "lambda_update",
      "x": 550,
      "y": 190,
      "width": 140,
      "height": 60,
      "text": "Lambda (Update)"
    },
    {
      "type": "shape",
      "id": "lambda_delete",
      "x": 550,
      "y": 260,
      "width": 140,
      "height": 60,
      "text": "Lambda (Delete)"
    },
    {
      "type": "shape",
      "id": "s3",
      "x": 750,
      "y": 100,
      "width": 120,
      "height": 60,
      "text": "S3 (Document Storage)"
    },
    {
      "type": "shape",
      "id": "dynamodb",
      "x": 750,
      "y": 200,
      "width": 140,
      "height": 60,
      "text": "DynamoDB (Metadata Storage)"
    },
    {
      "type": "line",
      "from": "client",
      "to": "direct_connect",
      "text": "Secure Connection"
    },
    {
      "type": "line",
      "from": "direct_connect",
      "to": "api_gateway",
      "text": "API Requests"
    },
    {
      "type": "line",
      "from": "api_gateway",
      "to": "lambda_create",
      "text": "POST /documents"
    },
    {
      "type": "line",
      "from": "api_gateway",
      "to": "lambda_read",
      "text": "GET /documents/{id}"
    },
    {
      "type": "line",
      "from": "api_gateway",
      "to": "lambda_update",
      "text": "PUT /documents/{id}"
    },
    {
      "type": "line",
      "from": "api_gateway",
      "to": "lambda_delete",
      "text": "DELETE /documents/{id}"
    },
    {
      "type": "line",
      "from": "lambda_create",
      "to": "s3",
      "text": "Upload Document"
    },
    {
      "type": "line",
      "from": "lambda_create",
      "to": "dynamodb",
      "text": "Store Metadata (GUID, S3 URL)"
    },
    {
      "type": "line",
      "from": "lambda_read",
      "to": "dynamodb",
      "text": "Fetch Metadata"
    },
    {
      "type": "line",
      "from": "lambda_read",
      "to": "s3",
      "text": "Generate Signed URL"
    },
    {
      "type": "line",
      "from": "lambda_update",
      "to": "s3",
      "text": "Replace Document"
    },
    {
      "type": "line",
      "from": "lambda_update",
      "to": "dynamodb",
      "text": "Update Metadata"
    },
    {
      "type": "line",
      "from": "lambda_delete",
      "to": "s3",
      "text": "Delete Document"
    },
    {
      "type": "line",
      "from": "lambda_delete",
      "to": "dynamodb",
      "text": "Remove Metadata"
    }
  ]
}

------------
Flow:
Create Document (Upload)

Client → API Gateway → Lambda (Create) → S3 (Store File)
Lambda → DynamoDB (Store Metadata) → Response to Client
Read Document (Retrieve)

Client → API Gateway → Lambda (Read) → DynamoDB (Get Metadata)
Lambda → S3 (Generate Signed URL) → Response to Client
Update Document

Client → API Gateway → Lambda (Update) → S3 (Replace File)
Lambda → DynamoDB (Update Metadata) → Response to Client
Delete Document

Client → API Gateway → Lambda (Delete) → S3 (Delete File)
Lambda → DynamoDB (Remove Metadata) → Response to Client
